// src/features/learn/services/patternEngine.ts
import { getSchemas } from "./patternSchemaRegistry";

import type {
  PatternSchema,
  Lexeme,
  POS,
  LangTag,
  VerbFeatures,
  UserInput,
  GramNumber,
} from "../types/patternCore.types";
import { useLexiconStore } from "@/stores/lexiconStore";
import { inflectVerb } from "./inflector";
import { inflectKoreanVerb } from "./koreanInflector";
import { getWordCategory } from "./wordCategories";
import coreVocabulary from "@/data/core-vocabulary.json";

export type GenerateParams = {
  schemaIds?: string[];
  tags?: LangTag[];
  limit?: number;
  chosenLexemeIds?: string[];
  userInput?: UserInput;
};

export type Generated = {
  text: string;
  korean: string;
  used: string[];
  schemaId: string;
  canWrite: boolean;
  confidence?: number;
};

// Î™ÖÏÇ¨ Î≥µÏàòÌòï Ìï®Ïàò
function inflectNoun(
  lemma: string,
  number: GramNumber,
  irregularPlural?: string
): string {
  if (number === "singular") return lemma;
  if (irregularPlural) return irregularPlural;
  if (/(s|sh|ch|x|z)$/i.test(lemma)) return lemma + "es";
  if (/[aeiou]y$/i.test(lemma)) return lemma + "s";
  if (/y$/i.test(lemma)) return lemma.slice(0, -1) + "ies";
  if (/fe$/i.test(lemma)) return lemma.slice(0, -2) + "ves";
  if (/f$/i.test(lemma)) return lemma.slice(0, -1) + "ves";
  return lemma + "s";
}

function realize(
  surface: string,
  koSurface: string | undefined,
  slots: PatternSchema["slots"],
  pick: (pos: POS | POS[], name: string, constraint?: string) => Lexeme | null,
  schemaId: string
) {
  let en = surface;
  let ko = koSurface || surface;
  const slotValues: Record<
    string,
    { word: string; pos: string; lexeme: Lexeme }
  > = {};
  const usedWords: Lexeme[] = [];

  // 1Îã®Í≥Ñ: Ïä¨Î°Ø Ï±ÑÏö∞Í∏∞
  for (const slot of slots) {
    console.log(
      `üéØ Ïä¨Î°Ø "${slot.name}" Ï≤òÎ¶¨ ÏãúÏûë (required: ${slot.required})`
    );
    let lx: Lexeme | null = null;

    if (slot.semanticConstraint) {
      const words = useLexiconStore.getState().words;
      const candidateWords = words.filter((w) => {
        if (!slot.accept.includes(w.pos)) return false;
        const categories = getWordCategory(w.en);
        const hasConstraint = categories.includes(slot.semanticConstraint!);
        return hasConstraint;
      });

      lx = candidateWords[0] || null;
      if (!lx) {
        console.warn(
          `‚ùå ${slot.name} Ï†úÏïΩÏ°∞Í±¥ "${slot.semanticConstraint}"ÏùÑ ÎßåÏ°±ÌïòÎäî Îã®Ïñ¥Í∞Ä ÏóÜÏùå`
        );
        return null;
      }
    } else {
      lx = pick(slot.accept, slot.name);
    }

    // ‚úÖ Í∞ïÌôîÎêú Ïä¨Î°Ø Í≤ÄÏ¶ù
    if (!lx || !lx.en || !lx.ko) {
      // ÌïÑÏàò Ïä¨Î°ØÏù∏ Í≤ΩÏö∞ Ìå®ÌÑ¥ ÏÉùÏÑ± Ïã§Ìå®
      if (slot.required !== false) {
        // requiredÍ∞Ä trueÏù¥Í±∞ÎÇò undefinedÏù∏ Í≤ΩÏö∞
        console.error(
          `‚ùå ÌïÑÏàò Ïä¨Î°Ø "${slot.name}"Ïóê Ï†ÅÏ†àÌïú Îã®Ïñ¥Í∞Ä ÏóÜÏùå - Ìå®ÌÑ¥ ÏÉùÏÑ± Ïã§Ìå®`
        );
        return null;
      }

      // ÏÑ†ÌÉùÏ†Å Ïä¨Î°ØÏù∏ Í≤ΩÏö∞ Ìï¥Îãπ Ïä¨Î°Ø Î∂ÄÎ∂ÑÏùÑ Ï†úÍ±∞
      console.warn(`‚ö†Ô∏è ÏÑ†ÌÉùÏ†Å Ïä¨Î°Ø "${slot.name}" ÏÉùÎûµ`);
      en = en.replace(new RegExp(`\\s*\\[?${slot.name}\\]?\\s*`, "g"), "");
      ko = ko.replace(new RegExp(`\\s*\\[?${slot.name}\\]?\\s*`, "g"), "");
      continue;
    }

    usedWords.push(lx);

    let enWord = lx.en;
    let koWord = lx.ko;

    // ÎèôÏÇ¨ ÌôúÏö©
    if (lx.pos === "VERB" && slot.morph) {
      enWord = inflectVerb(lx.en, slot.morph);
      koWord = inflectKoreanVerb(lx.ko, slot.morph);
    }

    en = en.replace(`[${slot.name}]`, enWord);
    ko = ko.replace(`[${slot.name}]`, koWord);
    slotValues[slot.name] = { word: koWord, pos: lx.pos, lexeme: lx };
    console.log(`üîÑ Ïä¨Î°Ø ÏπòÌôò: [${slot.name}] ‚Üí "${enWord}" (${koWord})`);
  }

  // ‚úÖ 2Îã®Í≥Ñ: ÏÉùÏÑ± ÌõÑ Í≤ÄÏ¶ù - Ïó¨Í∏∞Í∞Ä ÌïµÏã¨!

  // 2-1. Ïä¨Î°Ø ÎØ∏ÏôÑÏÑ± Í≤ÄÏ¶ù
  if (hasUnfilledSlots(en)) {
    console.warn(`‚ùå Ïä¨Î°Ø ÎØ∏ÏôÑÏÑ±: ${en}`);
    return null;
  }

  // 2-2. ÏùòÎØ∏Ï†Å Ìò∏ÌôòÏÑ± Í≤ÄÏ¶ù
  if (!validateSemanticCompatibility(usedWords, schemaId)) {
    console.warn(`‚ùå ÏùòÎØ∏Ï†Å Ìò∏ÌôòÏÑ± Ïã§Ìå®: ${en}`);
    return null;
  }

  // 2-3. Î¨∏Î≤ïÏ†Å Í∏∞Î≥∏ Í≤ÄÏ¶ù
  if (!basicGrammarCheck(en)) {
    console.warn(`‚ùå Í∏∞Î≥∏ Î¨∏Î≤ï Ïò§Î•ò: ${en}`);
    return null;
  }

  // ÏòÅÏñ¥ Î¨∏Î≤ï Î≥¥Ï†ï
  en = en.replace(/\ba ([aeiou])/gi, "an $1");
  en = en.charAt(0).toUpperCase() + en.slice(1);

  // ‚úÖ ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏòÅÏñ¥ ÌëúÌòÑ ÌõÑÏ≤òÎ¶¨ Ï∂îÍ∞Ä
  en = applyNaturalEnglishRules(en);

  console.log(`‚úÖ Í≤ÄÏ¶ù ÌÜµÍ≥º: "${en}" / "${ko}"`);
  return { en, ko };

  // ÏÉàÎ°úÏö¥ Ìï®Ïàò Ï∂îÍ∞Ä
  function applyNaturalEnglishRules(text: string): string {
    let result = text;

    // "home" Í¥ÄÎ†® ÏûêÏó∞Ïä§Îü¨Ïö¥ ÌëúÌòÑ
    result = result.replace(/\bat the home\b/gi, "at home");
    result = result.replace(/\bto the home\b/gi, "home");
    result = result.replace(/\bgo to home\b/gi, "go home");
    result = result.replace(/\bwent to home\b/gi, "went home");
    result = result.replace(/\bgoing to home\b/gi, "going home");

    // "school" Í¥ÄÎ†® (ÏùºÎ∂ÄÎäî "the"Í∞Ä ÌïÑÏöîÌïòÏßÄ ÏïäÏùå)
    result = result.replace(/\bgo to the school\b/gi, "go to school");
    result = result.replace(/\bat the school\b/gi, "at school");

    // "work/office" Í¥ÄÎ†®
    result = result.replace(/\bgo to the work\b/gi, "go to work");
    result = result.replace(/\bat the work\b/gi, "at work");

    return result;
  }
}

// ‚úÖ ÏÉàÎ°úÏö¥ Í≤ÄÏ¶ù Ìï®ÏàòÎì§ Ï∂îÍ∞Ä (realize Ìï®Ïàò ÏïÑÎûòÏóê)

function hasUnfilledSlots(text: string): boolean {
  // ÎåÄÍ¥ÑÌò∏Î°ú ÎëòÎü¨Ïã∏Ïù∏ ÎåÄÎ¨∏Ïûê Ïä¨Î°Ø Í∞êÏßÄ
  const slotPattern = /\[[A-Z_]+\]/g;
  const matches = text.match(slotPattern);

  if (matches) {
    console.error(`üö´ Î∞úÍ≤¨Îêú Îπà Ïä¨Î°ØÎì§: ${matches.join(", ")} in "${text}"`);
    return true;
  }

  // Ï∂îÍ∞Ä Í≤ÄÏÇ¨: ÎåÄÎ¨∏ÏûêÎ°úÎßå Ïù¥Î£®Ïñ¥ÏßÑ Îã®Ïñ¥Îì§ (TIME, PLACE Îì±)
  const upperCaseWords = text.match(/\b[A-Z]{2,}\b/g);
  if (upperCaseWords) {
    const suspiciousWords = upperCaseWords.filter((word) =>
      ["TIME", "PLACE", "PERSON", "ITEM", "VERB", "OBJECT"].includes(word)
    );

    if (suspiciousWords.length > 0) {
      console.error(
        `üö´ ÏùòÏã¨Ïä§Îü¨Ïö¥ ÎåÄÎ¨∏Ïûê Îã®Ïñ¥Îì§: ${suspiciousWords.join(
          ", "
        )} in "${text}"`
      );
      return true;
    }
  }

  return false;
}

function validateSemanticCompatibility(
  usedWords: Lexeme[],
  schemaId: string
): boolean {
  const verbs = usedWords.filter((w) => w.pos === "VERB");
  const objects = usedWords.filter(
    (w) => w.pos === "ITEM" || w.pos === "PLACE" || w.pos === "PERSON"
  );

  for (const verb of verbs) {
    for (const obj of objects) {
      if (!isValidVerbObjectCombination(verb.en, obj.en)) {
        console.log(`üö´ Î∂ÄÏ†ÅÏ†àÌïú Ï°∞Ìï©: ${verb.en} + ${obj.en}`);
        return false;
      }
    }
  }

  // ‚úÖ Ìå®ÌÑ¥Î≥Ñ ÌäπÎ≥Ñ Í≤ÄÏ¶ù
  if (schemaId === "MEET-PERSON-PLACE") {
    const place = usedWords.find((w) => w.pos === "PLACE");
    if (place && !isValidMeetingPlace(place.en)) {
      console.log(`üö´ Î∂ÄÏ†ÅÏ†àÌïú ÎßåÎÇ® Ïû•ÏÜå: ${place.en}`);
      return false;
    }
  }

  return true;
}

function isValidMeetingPlace(place: string): boolean {
  const invalidMeetingPlaces = ["hospital", "bathroom", "toilet"];
  return !invalidMeetingPlaces.includes(place.toLowerCase());
}

function isValidVerbObjectCombination(verb: string, object: string): boolean {
  // Î™ÖÌôïÌûà Î∂ÄÏ†ÅÏ†àÌïú Ï°∞Ìï©Îì§
  const invalidCombinations = [
    // Ïã†Ï≤¥ Î∂ÄÏúÑÎäî Ïù¥Îèô ÎèôÏÇ¨ÏôÄ Í≤∞Ìï© Î∂àÍ∞Ä
    {
      verbs: ["go", "goes", "went"],
      objects: ["teeth", "hair", "eyes", "nose", "mouth"],
    },
    // Ïï°Ï≤¥Îäî eatÍ≥º Í≤∞Ìï© Î∂àÍ∞Ä
    {
      verbs: ["eat", "eats", "ate"],
      objects: ["water", "coffee", "tea", "juice", "milk"],
    },
    // Í≥†Ï≤¥ ÏùåÏãùÏùÄ drinkÏôÄ Í≤∞Ìï© Î∂àÍ∞Ä
    {
      verbs: ["drink", "drinks", "drank"],
      objects: ["bread", "sandwich", "rice", "meat", "apple"],
    },
    // ÏÇ¨ÎûåÏùÄ eatÍ≥º Í≤∞Ìï© Î∂àÍ∞Ä
    {
      verbs: ["eat", "eats", "ate"],
      objects: ["friend", "teacher", "student", "person"],
    },
    // Ïû•ÏÜåÎäî eat/drinkÏôÄ Í≤∞Ìï© Î∂àÍ∞Ä
    {
      verbs: ["eat", "eats", "ate", "drink", "drinks", "drank"],
      objects: ["home", "school", "hospital", "office"],
    },
  ];

  return !invalidCombinations.some(
    (combo) =>
      combo.verbs.includes(verb.toLowerCase()) &&
      combo.objects.includes(object.toLowerCase())
  );
}

function basicGrammarCheck(text: string): boolean {
  // Í∏∞Î≥∏Ï†ÅÏù∏ Î¨∏Î≤ï Ïò§Î•ò Ï≤¥ÌÅ¨
  if (
    text.includes("goes teeth") ||
    text.includes("eat water") ||
    text.includes("drink bread")
  ) {
    return false;
  }
  return true;
}

// ÏÉàÎ°úÏö¥ Ìó¨Ìçº Ìï®ÏàòÎì§ Ï∂îÍ∞Ä
function findWordInCoreVocabulary(word: string) {
  const allWords = [
    ...coreVocabulary.places,
    ...coreVocabulary.items,
    ...coreVocabulary.people,
    ...coreVocabulary.time,
  ];
  return allWords.find((w) => w.en.toLowerCase() === word.toLowerCase());
}

// ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Î∂ÑÏÑù
function analyzeUserInput(userInput: UserInput): LangTag[] {
  const { content } = userInput;
  const keywords = content.toLowerCase();

  const tagMappings = {
    where: ["directions"],
    go: ["directions", "daily"],
    place: ["directions"],
    hospital: ["daily"],
    school: ["school", "daily"],
    when: ["daily"],
    time: ["daily", "school"],
    today: ["daily"],
    tomorrow: ["daily"],
    meet: ["daily"],
    friend: ["daily"],
    teacher: ["school"],
    Ïñ¥Îîî: ["directions"],
    ÎßåÎÇò: ["daily"],
    ÌïôÍµê: ["school"],
    Î≥ëÏõê: ["daily"],
    ÏãúÍ∞Ñ: ["daily"],
  };

  const suggestedTags: LangTag[] = [];
  Object.entries(tagMappings).forEach(([keyword, tags]) => {
    if (keywords.includes(keyword)) {
      suggestedTags.push(...tags);
    }
  });

  return suggestedTags.length > 0 ? [...new Set(suggestedTags)] : ["daily"];
}

// Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
function calculateConfidence(
  userInput: UserInput,
  result: { en: string; ko: string },
  schema: PatternSchema
): number {
  let confidence = 0.5;
  const content = userInput.content.toLowerCase();
  const text = result.en.toLowerCase();
  const korean = result.ko.toLowerCase();

  const keywords = content.split(/\s+/);
  for (const keyword of keywords) {
    if (text.includes(keyword) || korean.includes(keyword)) {
      confidence += 0.2;
    }
  }

  if (userInput.targetLanguage === "en" && schema.category === "daily") {
    confidence += 0.1;
  }

  return Math.min(confidence, 1.0);
}

// Î©îÏù∏ ÏÉùÏÑ± Ìï®Ïàò
export function generatePatterns(params: GenerateParams): Generated[] {
  const {
    schemaIds,
    tags = [],
    limit = 20,
    chosenLexemeIds = [],
    userInput,
  } = params;

  const words = useLexiconStore.getState().words;

  // ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Í∏∞Î∞ò ÌÉúÍ∑∏ Ï∂îÏ≤ú
  let finalTags = tags;
  if (userInput && tags.length === 0) {
    finalTags = analyzeUserInput(userInput);
    console.log(`ü§ñ ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏóêÏÑú Ï∂îÏ≤úÎêú ÌÉúÍ∑∏:`, finalTags);
  }

  const validWords = words.filter(
    (w) =>
      w.en && w.en.trim().length > 0 && w.ko && w.ko.trim().length > 0 && w.pos
  );

  console.log(
    `üìä Ï†ÑÏ≤¥ ${words.length}Í∞ú Ï§ë Ïú†Ìö®Ìïú Îã®Ïñ¥: ${validWords.length}Í∞ú`
  );

  const getWordsForPos = (
    acceptedPos: POS | POS[],
    usedIds: string[] = []
  ): Lexeme[] => {
    const posArray = Array.isArray(acceptedPos) ? acceptedPos : [acceptedPos];
    return validWords.filter(
      (w) => posArray.includes(w.pos) && !usedIds.includes(w.id)
    );
  };

  // ÌÖúÌîåÎ¶ø ÏÜåÏä§ Ï†ÑÌôò
  const all = getSchemas();
  const templates = schemaIds?.length
    ? all.filter((s) => schemaIds.includes(s.id))
    : all.filter((s) => {
        const isProblematic = [
          "WHAT-ARE-YOU-DOING-TIME",
          "CAN-WE-MEET-TIME",
          "GO-PLACE-TIME",
        ].includes(s.id);

        if (isProblematic) {
          console.warn(`‚è≠Ô∏è Î¨∏Ï†ú Ìå®ÌÑ¥ Ï†úÏô∏: ${s.id}`);
          return false;
        }

        // ‚úÖ ÌïúÍµ≠Ïñ¥ Î≤àÏó≠ ÎàÑÎùΩ Ìå®ÌÑ¥ Ï†úÏô∏
        const hasValidKorean = s.koSurface && s.koSurface !== s.surface;
        const hasDefaultTranslation =
          getDefaultKoreanTranslation(s.surface, s.id) !== s.surface;

        if (!hasValidKorean && !hasDefaultTranslation) {
          console.warn(`‚è≠Ô∏è ÌïúÍµ≠Ïñ¥ Î≤àÏó≠ ÎàÑÎùΩÏúºÎ°ú Ìå®ÌÑ¥ Ï†úÏô∏: ${s.id}`);
          return false;
        }

        return finalTags.length ? finalTags.includes(s.category) : true;
      });

  console.log(`üìã ÏÇ¨Ïö©Ìï† Ìå®ÌÑ¥ ÌÖúÌîåÎ¶ø: ${templates.length}Í∞ú`);

  const out: Generated[] = [];

  for (const t of templates) {
    console.log(`üéØ Ìå®ÌÑ¥ "${t.id}" ÏãúÎèÑ Ï§ë...`);

    const usedInThisPattern: string[] = [];
    let canCreatePattern = true;

    // Í∞Å Ïä¨Î°ØÎ≥ÑÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Îã®Ïñ¥ Ï≤¥ÌÅ¨
    for (const slot of t.slots) {
      const availableForSlot = getWordsForPos(slot.accept, usedInThisPattern);
      if (availableForSlot.length === 0) {
        console.log(
          `‚è≠Ô∏è ${t.id} Í±¥ÎÑàÎõ∞Í∏∞ - ${slot.name} Ïä¨Î°ØÏóê ÏÇ¨Ïö©Ìï† Îã®Ïñ¥ ÏóÜÏùå`
        );
        canCreatePattern = false;
        break;
      }
    }

    if (!canCreatePattern) continue;

    const pick = (
      pos: POS | POS[],
      name: string,
      constraint?: string
    ): Lexeme | null => {
      let available = getWordsForPos(pos, usedInThisPattern);

      // ‚úÖ Ï†úÏïΩ Ï°∞Í±¥Ïù¥ ÏûàÏúºÎ©¥ ÌïÑÌÑ∞ÎßÅ
      if (constraint) {
        available = available.filter((w) => {
          const categories = getWordCategory(w.en);
          return categories.includes(constraint);
        });

        console.log(
          `üîç ${name}(${constraint}) Ï†úÏïΩ ÌõÑ ÌõÑÎ≥¥: ${available.length}Í∞ú`
        );
      }

      if (available.length === 0) {
        console.warn(`‚ùå ${name} - ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Îã®Ïñ¥ ÏóÜÏùå`);
        return null;
      }

      const selected = available[0];
      usedInThisPattern.push(selected.id);
      console.log(`‚úÖ ${name} -> "${selected.en}"(${selected.ko}) ÏÑ†ÌÉù`);
      return selected;
    };

    const result = realize(t.surface, t.koSurface, t.slots, pick, t.id);
    if (result) {
      const confidence = userInput
        ? calculateConfidence(userInput, result, t)
        : 1.0;

      console.log(`üéâ Ìå®ÌÑ¥ ÏÉùÏÑ± ÏÑ±Í≥µ: "${result.en}" / "${result.ko}"`);
      out.push({
        text: result.en,
        korean: result.ko,
        used: usedInThisPattern,
        schemaId: t.id,
        canWrite: false,
        confidence,
      });
    }

    if (out.length >= limit) break;
  }

  // Ïã†Î¢∞ÎèÑ ÏàúÏúºÎ°ú Ï†ïÎ†¨
  out.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));

  console.log(`üèÅ ÏµúÏ¢Ö ÏÉùÏÑ±Îêú Ìå®ÌÑ¥: ${out.length}Í∞ú`);
  return out;
}

// Í∏∞Î≥∏ ÌïúÍµ≠Ïñ¥ Î≤àÏó≠ Ï†úÍ≥µ Ìï®Ïàò
function getDefaultKoreanTranslation(
  surface: string,
  schemaId: string
): string {
  const translations: Record<string, string> = {
    "For here or to go?": "Îß§Ïû•ÏóêÏÑú ÎìúÏã§ Í±¥Í∞ÄÏöî, Ìè¨Ïû•ÌïòÏã§ Í±¥Í∞ÄÏöî?",
    "What size would you like?": "ÏÇ¨Ïù¥Ï¶àÎäî Ïñ¥ÎñªÍ≤å ÌïòÏãúÍ≤†Ïñ¥Ïöî?",
    "Could you make it OPTION?": "OPTIONÏúºÎ°ú ÎßåÎì§Ïñ¥ Ï£ºÏÑ∏Ïöî.",
    "I'd like it with MILK.": "MILKÎ•º ÎÑ£Ïñ¥ÏÑú Ï£ºÏÑ∏Ïöî.",
    "Can I have a receipt?": "ÏòÅÏàòÏ¶ù Ï£ºÏÑ∏Ïöî.",
  };

  return translations[surface] || surface;
}
